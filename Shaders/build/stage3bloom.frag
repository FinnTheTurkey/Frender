#version 330 core
layout (location = 0) out vec4 FragColor;

in vec2 tex_coords;

uniform sampler2D frame;

uniform bool horizontal;
uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);

uniform float gWeights[2] =float [] (
    0.44908,
    0.05092
);
uniform float gOffsets[2] =float [] (
    0.53805,
    2.06278
);

// https://software.intel.com/content/www/us/en/develop/blogs/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms.html
// automatically generated by GenerateGaussFunctionCode in GaussianBlur.h
vec3 GaussianBlur( sampler2D tex0, vec2 centreUV, vec2 pixelOffset )
{
    vec3 colOut = vec3( 0, 0, 0 );

    ////////////////////////////////////////////////;
    // Kernel width 7 x 7
    //
    const int stepCount = 2;
    //

    ////////////////////////////////////////////////;

    for( int i = 0; i < stepCount; i++ )
    {
        vec2 texCoordOffset = gOffsets[i] * pixelOffset;
        vec3 col = texture(tex0, centreUV + texCoordOffset).xyz + 
                    texture(tex0, centreUV - texCoordOffset).xyz;
        colOut += gWeights[i] * col;
    }

    return colOut;
}

void main()
{
    vec2 tex_offset = 1.0 / textureSize(frame, 0); // gets size of single texel
    // vec3 result = texture(frame, tex_coords).rgb; // * weight[0]; // current fragment's contribution
    // if(horizontal)
    // {
    //     for(int i = 1; i < 5; ++i)
    //     {
    //         result += texture(frame, tex_coords + vec2(tex_offset.x * i, 0.0)).rgb * weight[i];
    //         result += texture(frame, tex_coords - vec2(tex_offset.x * i, 0.0)).rgb * weight[i];
    //     }
    // }
    // else
    // {
    //     for(int i = 1; i < 5; ++i)
    //     {
    //         result += texture(frame, tex_coords + vec2(0.0, tex_offset.y * i)).rgb * weight[i];
    //         result += texture(frame, tex_coords - vec2(0.0, tex_offset.y * i)).rgb * weight[i];
    //     }
    // }

    vec2 txo;

    if (horizontal)
    {
        txo = vec2(tex_offset.x, 0);
    }
    else
    {
        txo = vec2(0, tex_offset.y);
    }

    vec3 result = GaussianBlur(frame, tex_coords, txo);
    FragColor = vec4(result, 1.0);
    // FragColor = vec4(0, 1, 0, 1);
}